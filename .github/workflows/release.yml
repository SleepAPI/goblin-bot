name: Release

on:
  push:
    branches:
      - main


env:
  NODE_VERSION: 22
  DEPLOY_DIR: goblin-bot
  APP_NAME: goblin-bot

jobs:
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install
        run: npm ci

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: goblin-bot-${{ github.sha }}
          if-no-files-found: error
          path: |
            dist/
            package.json
            package-lock.json

  deploy-discord-commands:
    name: Deploy Discord commands
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install
        run: npm ci

      - name: Deploy
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_GUILD_ID: ${{ secrets.DISCORD_GUILD_ID }}
        run: |
          if [ -z "${DISCORD_GUILD_ID:-}" ]; then unset DISCORD_GUILD_ID; fi
          npm run deploy

  deploy-server:
    name: Deploy to server
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: goblin-bot-${{ github.sha }}

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_GUILD_ID: ${{ secrets.DISCORD_GUILD_ID }}
          CLASH_OF_CLANS_API_TOKEN: ${{ secrets.CLASH_OF_CLANS_API_TOKEN }}
          CLASH_OF_CLANS_API_BASE_URL: ${{ vars.CLASH_OF_CLANS_API_BASE_URL }}
          CLASH_OF_CLANS_API_TIMEOUT_MS: ${{ vars.CLASH_OF_CLANS_API_TIMEOUT_MS }}
          BOT_INSTANCE_LABEL: ${{ vars.BOT_INSTANCE_LABEL }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}
        run: |
          if [ -z "$SSH_HOST" ]; then
            echo "Missing required secret: SSH_HOST"
            exit 1
          fi

          echo "Deploying to $SSH_HOST:${{ env.DEPLOY_DIR }}"

          ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR "$SSH_HOST" "mkdir -p '${{ env.DEPLOY_DIR }}'"

          rsync -az --delete -e "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR" dist/ "$SSH_HOST":"${{ env.DEPLOY_DIR }}"/dist/
          rsync -az -e "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR" package.json package-lock.json "$SSH_HOST":"${{ env.DEPLOY_DIR }}"/

          ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR "$SSH_HOST" << ENDSSH
            set -euo pipefail
            
            DEPLOY_PATH="\$HOME/${{ env.DEPLOY_DIR }}"
            
            # Set environment variables for PM2
            export NODE_ENV="production"
            export DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            export APP_NAME="${{ env.APP_NAME }}"
            export NODE_VERSION="${{ env.NODE_VERSION }}"
            export DISCORD_TOKEN="${{ secrets.DISCORD_TOKEN }}"
            export DISCORD_CLIENT_ID="${{ secrets.DISCORD_CLIENT_ID }}"
            export DISCORD_GUILD_ID="${{ secrets.DISCORD_GUILD_ID }}"
            export CLASH_OF_CLANS_API_TOKEN="${{ secrets.CLASH_OF_CLANS_API_TOKEN }}"
            export CLASH_OF_CLANS_API_BASE_URL="${{ vars.CLASH_OF_CLANS_API_BASE_URL }}"
            export CLASH_OF_CLANS_API_TIMEOUT_MS="${{ vars.CLASH_OF_CLANS_API_TIMEOUT_MS }}"
            export BOT_INSTANCE_LABEL="${{ vars.BOT_INSTANCE_LABEL }}"
            export LOG_LEVEL="${{ vars.LOG_LEVEL }}"
            
            # Important: GitHub passes unset secrets/vars as empty strings. Our Zod env parsing
            # treats empty strings as "present", which breaks .optional() + .default().
            if [ -z "\${DISCORD_GUILD_ID:-}" ]; then unset DISCORD_GUILD_ID; fi
            if [ -z "\${CLASH_OF_CLANS_API_TOKEN:-}" ]; then unset CLASH_OF_CLANS_API_TOKEN; fi
            if [ -z "\${CLASH_OF_CLANS_API_BASE_URL:-}" ]; then unset CLASH_OF_CLANS_API_BASE_URL; fi
            if [ -z "\${CLASH_OF_CLANS_API_TIMEOUT_MS:-}" ]; then unset CLASH_OF_CLANS_API_TIMEOUT_MS; fi
            if [ -z "\${BOT_INSTANCE_LABEL:-}" ]; then unset BOT_INSTANCE_LABEL; fi
            if [ -z "\${LOG_LEVEL:-}" ]; then unset LOG_LEVEL; fi
            
            # Log environment variables (masking sensitive values)
            echo "=== Environment Variables ==="
            echo "DEPLOY_DIR=\$DEPLOY_DIR"
            echo "APP_NAME=\$APP_NAME"
            echo "NODE_VERSION=\$NODE_VERSION"
            echo "NODE_ENV=\$NODE_ENV"
            echo "DISCORD_TOKEN=\${DISCORD_TOKEN:+SET (\${#DISCORD_TOKEN} chars)}"
            echo "DISCORD_CLIENT_ID=\$DISCORD_CLIENT_ID"
            echo "DISCORD_GUILD_ID=\${DISCORD_GUILD_ID:-<not set>}"
            echo "CLASH_OF_CLANS_API_TOKEN=\${CLASH_OF_CLANS_API_TOKEN:+SET (\${#CLASH_OF_CLANS_API_TOKEN} chars)}"
            echo "CLASH_OF_CLANS_API_BASE_URL=\${CLASH_OF_CLANS_API_BASE_URL:-<not set>}"
            echo "CLASH_OF_CLANS_API_TIMEOUT_MS=\${CLASH_OF_CLANS_API_TIMEOUT_MS:-<not set>}"
            echo "BOT_INSTANCE_LABEL=\${BOT_INSTANCE_LABEL:-<not set>}"
            echo "LOG_LEVEL=\${LOG_LEVEL:-<not set>}"
            echo "============================="
            
            : "\${DISCORD_TOKEN:?Missing DISCORD_TOKEN (configure GitHub Secret)}"
            : "\${DISCORD_CLIENT_ID:?Missing DISCORD_CLIENT_ID (configure GitHub Secret)}"

            cd "\$DEPLOY_PATH"

            # Load nvm and use the correct Node version (same approach as SleepAPI)
            export NVM_DIR="\$HOME/.nvm"
            [ -s "\$NVM_DIR/nvm.sh" ] && \. "\$NVM_DIR/nvm.sh"

            # Use the Node version specified
            nvm install "${NODE_VERSION:-22}" || true
            nvm use "${NODE_VERSION:-22}"

            # Verify npm is available
            if ! command -v npm >/dev/null 2>&1; then
              echo "ERROR: npm is not available after nvm use"
              echo "HOME: \$HOME"
              echo "NVM_DIR: \$NVM_DIR"
              echo "PATH: \$PATH"
              echo "Node version: \$(command -v node || echo 'not found')"
              exit 1
            fi
            echo "Using Node.js \$(node --version) and npm \$(npm --version)"

            # Verify package files are present
            echo "Checking for package files in \$DEPLOY_PATH..."
            ls -la "\$DEPLOY_PATH" | grep -E "(package.json|package-lock.json)" || echo "WARNING: package files not found"
            
            if [ ! -f "\$DEPLOY_PATH/package-lock.json" ]; then
              echo "ERROR: package-lock.json not found in \$DEPLOY_PATH"
              echo "Contents of \$DEPLOY_PATH:"
              ls -la "\$DEPLOY_PATH"
              exit 1
            fi

            # Install build dependencies if not already present (needed for native modules)
            if ! command -v make >/dev/null 2>&1; then
              echo "Installing build dependencies..."
              if command -v apt-get >/dev/null 2>&1; then
                DEBIAN_FRONTEND=noninteractive apt-get update -qq
                DEBIAN_FRONTEND=noninteractive apt-get install -y -qq build-essential python3
              elif command -v yum >/dev/null 2>&1; then
                yum install -y -q gcc gcc-c++ make python3
              elif command -v apk >/dev/null 2>&1; then
                apk add --no-cache build-base python3
              fi
            fi

            npm ci --omit=dev

            # PM2 process management
            echo "=== PM2 Process Management ==="
            if command -v pm2 >/dev/null 2>&1; then
              echo "pm2 is available at: \$(command -v pm2)"
              echo "Current PM2 processes:"
              pm2 list || echo "pm2 list failed"
              
              # Verify the entry point exists
              ENTRY_POINT="\$DEPLOY_PATH/dist/index.js"
              echo "Checking for entry point: \$ENTRY_POINT"
              if [ ! -f "\$ENTRY_POINT" ]; then
                echo "ERROR: Entry point not found at \$ENTRY_POINT"
                echo "Contents of \$DEPLOY_PATH/dist:"
                ls -la "\$DEPLOY_PATH/dist" 2>/dev/null || echo "dist directory does not exist"
                exit 1
              fi
              echo "✓ Entry point exists"
              
              # Check if process exists
              if pm2 describe "\$APP_NAME" > /dev/null 2>&1; then
                echo "Process '\$APP_NAME' exists, restarting..."
                pm2 restart "\$APP_NAME" --update-env
                RESTART_RESULT=\$?
                if [ \$RESTART_RESULT -ne 0 ]; then
                  echo "ERROR: pm2 restart failed with exit code \$RESTART_RESULT"
                  pm2 logs "\$APP_NAME" --lines 20 --nostream || true
                  exit 1
                fi
              else
                echo "Process '\$APP_NAME' does not exist, starting..."
                pm2 start "\$ENTRY_POINT" --name "\$APP_NAME" --time
                START_RESULT=\$?
                if [ \$START_RESULT -ne 0 ]; then
                  echo "ERROR: pm2 start failed with exit code \$START_RESULT"
                  pm2 logs "\$APP_NAME" --lines 20 --nostream || true
                  exit 1
                fi
              fi
              
              # Verify process is running
              echo "Verifying process status..."
              pm2 list
              if pm2 list | grep -q "\$APP_NAME.*online"; then
                echo "✓ Process '\$APP_NAME' is online"
                pm2 save
                echo "✓ PM2 process list saved"
              else
                echo "ERROR: Process '\$APP_NAME' is not online"
                echo "PM2 status:"
                pm2 describe "\$APP_NAME" || echo "pm2 describe failed"
                echo "Recent logs:"
                pm2 logs "\$APP_NAME" --lines 30 --nostream || echo "pm2 logs failed"
                exit 1
              fi
            else
              echo "ERROR: pm2 is not installed on server"
              echo "PATH: \$PATH"
              exit 1
            fi
            echo "============================="
          ENDSSH
